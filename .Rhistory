theme(plot.title = element_text(hjust = 0.5))
# Plot 2: Log(Close) with rolling statistics
p2 <- ggplot(data, aes(x = Date)) +
geom_line(aes(y = log_Close), color = "steelblue", linewidth = 0.6) +
geom_line(aes(y = log_Close_rolling_mean), color = "red", linewidth = 1, linetype = "dashed", na.rm = TRUE) +
geom_ribbon(aes(ymin = log_Close_rolling_mean - log_Close_rolling_sd,
ymax = log_Close_rolling_mean + log_Close_rolling_sd),
alpha = 0.2, fill = "red", na.rm = TRUE) +
labs(title = "Log(Close) with Rolling Mean ± SD (60-day window)",
x = "Date",
y = "Log(Close Price)") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Plot 3: ACF of Close
acf_close <- acf(data$Close, plot = FALSE, na.action = na.pass)
acf_df_close <- data.frame(Lag = acf_close$lag[,1,1], ACF = acf_close$acf[,1,1])
# Exclude lag 0 (always 1.0) to better see other lags
acf_df_close <- acf_df_close %>% filter(Lag > 0)
p3 <- ggplot(acf_df_close, aes(x = Lag, y = ACF)) +
geom_bar(stat = "identity", fill = "steelblue", width = 0.5) +
geom_hline(yintercept = 0, color = "black") +
geom_hline(yintercept = c(-1.96/sqrt(length(data$Close)), 1.96/sqrt(length(data$Close))),
linetype = "dashed", color = "red", alpha = 0.7) +
labs(title = "ACF of Close Price",
x = "Lag",
y = "ACF") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Plot 4: ACF of Log(Close)
acf_logclose <- acf(data$log_Close, plot = FALSE, na.action = na.pass)
acf_df_logclose <- data.frame(Lag = acf_logclose$lag[,1,1], ACF = acf_logclose$acf[,1,1])
# Exclude lag 0 (always 1.0) to better see other lags
acf_df_logclose <- acf_df_logclose %>% filter(Lag > 0)
p4 <- ggplot(acf_df_logclose, aes(x = Lag, y = ACF)) +
geom_bar(stat = "identity", fill = "steelblue", width = 0.5) +
geom_hline(yintercept = 0, color = "black") +
geom_hline(yintercept = c(-1.96/sqrt(length(data$log_Close)), 1.96/sqrt(length(data$log_Close))),
linetype = "dashed", color = "red", alpha = 0.7) +
labs(title = "ACF of Log(Close Price)",
x = "Lag",
y = "ACF") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Combine plots
grid.arrange(p1, p2, p3, p4, ncol = 2)
# Plot log returns r(t)
ggplot(data, aes(x = Date, y = returns)) +
geom_line(color = "steelblue", linewidth = 0.6) +
geom_hline(yintercept = 0, color = "red", linetype = "dashed", alpha = 0.7) +
labs(title = "Log Returns r(t) = log(C_t) - log(C_{t-1})",
x = "Date",
y = "Log Returns") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# ADF Test (Augmented Dickey-Fuller)
# Test null hypothesis: series has unit root (non-stationary)
x <- na.omit(data$returns)
adf.test(x)
# KPSS Test (Kwiatkowski-Phillips-Schmidt-Shin)
# Test null hypothesis: series is stationary
kpss.test(data$returns, null = "Trend")
prepare_regression_data <- function(data) {
# Create log returns (dependent variable)
data$log_returns <- c(NA, diff(log(data$Close)))
# Create regressors
# r_{t-1} (lagged return)
data$lag_return <- lag(data$log_returns, 1)
# log(H_t / L_t) (intraday range = volatility proxy)
data$intraday_range <- log(data$High / data$Low)
# Δlog(Volume_t) (volume change)
data$log_Volume <- log(data$Volume)
data$delta_log_Volume <- c(NA, diff(data$log_Volume))
# Remove rows with NA values
data <- data %>% filter(!is.na(log_returns),
!is.na(lag_return),
!is.na(delta_log_Volume),
!is.na(intraday_range))
return(data)
}
# Prepare regression data
data_reg <- prepare_regression_data(data)
fit_model1 <- function(data) {
# Model: r_t = β₀ + β₁*r_{t-1} + β₂*Δlog(Vol_t) + β₃*log(H_t/L_t) + ε_t
model1 <- lm(log_returns ~ lag_return + delta_log_Volume + intraday_range,
data = data)
return(model1)
}
model1 <- fit_model1(data_reg)
summary(model1)
# Extract residuals from Model 1
res1 <- residuals(model1)
# ACF of residuals (show up to 40 lags, exclude lag 0)
acf_res_m1 <- acf(res1, lag.max = 40, plot = FALSE, na.action = na.pass)
acf_df_m1 <- data.frame(Lag = acf_res_m1$lag[,1,1], ACF = acf_res_m1$acf[,1,1]) %>%
filter(Lag > 0)
ggplot(acf_df_m1, aes(x = Lag, y = ACF)) +
geom_bar(stat = "identity", fill = "steelblue", width = 0.5) +
geom_hline(yintercept = 0, color = "black") +
geom_hline(yintercept = c(-1.96, 1.96) / sqrt(length(res1)),
linetype = "dashed", color = "red", alpha = 0.7) +
labs(title = "ACF of Residuals - Model 1 (OLS)",
x = "Lag",
y = "ACF") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# PACF of residuals
pacf_res_m1 <- pacf(res1, plot = FALSE, na.action = na.pass)
pacf_df_res_m1 <- data.frame(Lag = as.numeric(pacf_res_m1$lag), PACF = as.numeric(pacf_res_m1$acf))
p_pacf_m1 <- ggplot(pacf_df_res_m1, aes(x = Lag, y = PACF)) +
geom_bar(stat = "identity", fill = "darkgreen", width = 0.5) +
geom_hline(yintercept = 0, color = "black") +
geom_hline(yintercept = c(-1.96/sqrt(length(res1)), 1.96/sqrt(length(res1))),
linetype = "dashed", color = "red", alpha = 0.7) +
labs(title = "PACF of Residuals - Model 1 (OLS)",
x = "Lag",
y = "PACF") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Ljung-Box test
Box.test(res1, lag = 10, type = "Ljung-Box")
y  <- data_reg$log_returns
xreg <- cbind(data_reg$lag_return, data_reg$delta_log_Volume, data_reg$intraday_range)
# Non-seasonal
fit_ns <- auto.arima(y, xreg = xreg, seasonal = FALSE)
# Seasonal weekly
y7 <- ts(y, frequency = 7)
fit_s <- auto.arima(y7, xreg = xreg, seasonal = TRUE)
AIC(fit_ns, fit_s)
BIC(fit_ns, fit_s)
checkresiduals(fit_ns)
checkresiduals(fit_s)
res2 <- residuals(fit_s)
res2 <- res2[!is.na(res2)]
# Plot ACF of squared residuals
acf(res2^2, main = "ACF of Squared Residuals (Volatility Clustering Check)")
Box.test(res2^2, type = "Ljung-Box")
# ARCH LM Test
# Null hypothesis: No ARCH effects (homoskedasticity)
arch7  <- ArchTest(res2, lags = 7)
arch14 <- ArchTest(res2, lags = 14)
arch21 <- ArchTest(res2, lags = 21)
arch7; arch14; arch21
# Prepare train/test data for GARCH modeling
data_reg_tr <- prepare_regression_data(data_train)
data_reg_te <- prepare_regression_data(data_test)
xreg_tr <- cbind(data_reg_tr$lag_return, data_reg_tr$delta_log_Volume, data_reg_tr$intraday_range)
xreg_te <- cbind(data_reg_te$lag_return, data_reg_te$delta_log_Volume, data_reg_te$intraday_range)
fit_mean <- Arima(
ts(data_reg_tr$log_returns, frequency = 7),
order = c(1,0,2),
seasonal = list(order = c(1,0,0), period = 7),
xreg = xreg_tr,
method = "ML"
)
h <- length(data_reg_te$log_returns)
fc_mean <- forecast(fit_mean, h = h, xreg = xreg_te)
mu_hat <- as.numeric(fc_mean$mean)  # mean return forecasts for test horizon
res_tr <- as.numeric(residuals(fit_mean))
res_tr <- res_tr[is.finite(res_tr)]
spec <- ugarchspec(
variance.model = list(model="eGARCH", garchOrder=c(1,1)),
mean.model     = list(armaOrder=c(0,0), include.mean=FALSE),
distribution.model = "sstd"
)
fit_vol <- ugarchfit(spec, data = res_tr, solver = "hybrid")
fc_vol <- ugarchforecast(fit_vol, n.ahead = h)
sigma_eps_hat <- as.numeric(sigma(fc_vol))  # volatility of residual shocks
rmse_mean <- sqrt(mean((data_reg_te$log_returns - mu_hat)^2, na.rm=TRUE))
mae_mean  <- mean(abs(data_reg_te$log_returns - mu_hat), na.rm=TRUE)
dir_acc   <- mean(sign(data_reg_te$log_returns) == sign(mu_hat), na.rm=TRUE)
c(RMSE_mean=rmse_mean, MAE_mean=mae_mean, Directional_Accuracy=dir_acc)
err_te <- data_reg_te$log_returns - mu_hat
realized_var <- err_te^2
pred_var <- sigma_eps_hat^2
# QLIKE loss: lower is better (very common for volatility forecast evaluation)
qlike <- mean(log(pred_var) + realized_var / pred_var, na.rm=TRUE)
# MSE on variance proxy (also common)
mse_var <- mean((realized_var - pred_var)^2, na.rm=TRUE)
c(QLIKE=qlike, MSE_Var=mse_var)
plot(mu_hat, type="l", main="Forecasted mean return (test horizon)")
lines(data_reg_te$log_returns, type="l")  # overlay actual returns
plot(sigma_eps_hat, type="l", main="Forecasted volatility (sigma) of returns")
lines(abs(err_te), type="l")  # crude realized-vol proxy
mu0 <- rep(0, length(y_te))
rmse0 <- sqrt(mean((y_te - mu0)^2, na.rm=TRUE))
mu0 <- rep(0, length(data_reg_te$log_returns))
rmse0 <- sqrt(mean((data_reg_te$log_returns - mu0)^2, na.rm=TRUE))
mae0  <- mean(abs(data_reg_te$log_returns - mu0), na.rm=TRUE)
dir0  <- mean(sign(data_reg_te$log_returns) == sign(mu0), na.rm=TRUE)  # will be weird b/c sign(0)=0
c(RMSE0=rmse0, MAE0=mae0)
# Vol baseline: constant variance = var(train residuals)
const_var <- rep(var(err_te, na.rm=TRUE), length(err_te))  # or var(res_tr)
qlike0 <- mean(log(const_var) + (err_te^2)/const_var, na.rm=TRUE)
mse0   <- mean((err_te^2 - const_var)^2, na.rm=TRUE)
c(QLIKE0=qlike0, MSE0=mse0)
knitr::opts_chunk$set(
echo = TRUE,
warning = FALSE,
message = FALSE,
fig.width = 10,
fig.height = 6,
fig.align = "center"
)
# Load required libraries
library(dplyr)
library(ggplot2)
library(gridExtra)
library(forecast)
library(lmtest)
library(tseries)
library(zoo)
library(lubridate)
library(knitr)
library(rugarch)
library(FinTS)
# Load and clean data function
load_and_clean_data <- function(file_path) {
# Read CSV file (skip second row if it contains currency info)
data <- read.csv(file_path, stringsAsFactors = FALSE)
# Remove second row if it looks like a header row
if (nrow(data) > 1 && grepl("BTC-USD|USD", data[1, 2], ignore.case = TRUE)) {
data <- data[-1, ]
}
# Parse Date as datetime
data$Date <- as.Date(data$Date, format = "%Y-%m-%d")
# Convert numeric columns
data$Close <- as.numeric(data$Close)
data$Open <- as.numeric(data$Open)
data$High <- as.numeric(data$High)
data$Low <- as.numeric(data$Low)
data$Volume <- as.numeric(data$Volume)
# Sort ascending by date
data <- data %>% arrange(Date)
# Drop duplicates (keep first occurrence)
data <- data %>% distinct(Date, .keep_all = TRUE)
# Remove rows with missing values
data <- data %>% filter(!is.na(Date), !is.na(Close), !is.na(Volume))
return(data)
}
check_trading_days <- function(data) {
# Extract weekday (1 = Monday, 7 = Sunday)
data$Weekday <- wday(data$Date, week_start = 1)
# Check if weekends exist
has_weekends <- any(data$Weekday %in% c(6, 7))  # Saturday = 6, Sunday = 7
# Count days
total_days <- nrow(data)
weekend_count <- sum(data$Weekday %in% c(6, 7))
result <- list(
has_weekends = has_weekends,
total_days = total_days,
weekend_count = weekend_count
)
return(result)
}
# Set the CSV file path (modify as needed)
csv_file <- "archive/bitcoin.csv"
# Load and clean data
data <- load_and_clean_data(csv_file)
# Check trading days
check_trading_days(data)
# Plot Close and Volume over time
p1 <- ggplot(data, aes(x = Date, y = Close)) +
geom_line(color = "steelblue", linewidth = 0.6) +
labs(title = "Close Price Over Time",
x = "Date",
y = "Close Price") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
p2 <- ggplot(data, aes(x = Date, y = Volume)) +
geom_line(color = "darkgreen", linewidth = 0.6) +
labs(title = "Volume Over Time",
x = "Date",
y = "Volume") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Combine plots
grid.arrange(p1, p2, ncol = 1)
# Create series
data$log_Close <- log(data$Close)
data$log_Volume <- log(data$Volume)
# Calculate returns
data$returns <- c(NA, diff(data$log_Close))
# Define window for rolling statistics
window <- min(60, floor(nrow(data) / 10))
# Calculate rolling statistics
data$Close_rolling_mean <- rollmean(data$Close, k = window, fill = NA, align = "right")
data$Close_rolling_sd <- rollapply(data$Close, width = window, FUN = sd, fill = NA, align = "right")
data$log_Close_rolling_mean <- rollmean(data$log_Close, k = window, fill = NA, align = "right")
data$log_Close_rolling_sd <- rollapply(data$log_Close, width = window, FUN = sd, fill = NA, align = "right")
# Plot 1: Close Price with rolling statistics
p1 <- ggplot(data, aes(x = Date)) +
geom_line(aes(y = Close), color = "steelblue", linewidth = 0.6) +
geom_line(aes(y = Close_rolling_mean), color = "red", linewidth = 1, linetype = "dashed", na.rm = TRUE) +
geom_ribbon(aes(ymin = Close_rolling_mean - Close_rolling_sd,
ymax = Close_rolling_mean + Close_rolling_sd),
alpha = 0.2, fill = "red", na.rm = TRUE) +
labs(title = "Close Price with Rolling Mean ± SD (60-day window)",
x = "Date",
y = "Close Price") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Plot 2: Log(Close) with rolling statistics
p2 <- ggplot(data, aes(x = Date)) +
geom_line(aes(y = log_Close), color = "steelblue", linewidth = 0.6) +
geom_line(aes(y = log_Close_rolling_mean), color = "red", linewidth = 1, linetype = "dashed", na.rm = TRUE) +
geom_ribbon(aes(ymin = log_Close_rolling_mean - log_Close_rolling_sd,
ymax = log_Close_rolling_mean + log_Close_rolling_sd),
alpha = 0.2, fill = "red", na.rm = TRUE) +
labs(title = "Log(Close) with Rolling Mean ± SD (60-day window)",
x = "Date",
y = "Log(Close Price)") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Plot 3: ACF of Close
acf_close <- acf(data$Close, plot = FALSE, na.action = na.pass)
acf_df_close <- data.frame(Lag = acf_close$lag[,1,1], ACF = acf_close$acf[,1,1])
# Exclude lag 0 (always 1.0) to better see other lags
acf_df_close <- acf_df_close %>% filter(Lag > 0)
p3 <- ggplot(acf_df_close, aes(x = Lag, y = ACF)) +
geom_bar(stat = "identity", fill = "steelblue", width = 0.5) +
geom_hline(yintercept = 0, color = "black") +
geom_hline(yintercept = c(-1.96/sqrt(length(data$Close)), 1.96/sqrt(length(data$Close))),
linetype = "dashed", color = "red", alpha = 0.7) +
labs(title = "ACF of Close Price",
x = "Lag",
y = "ACF") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Plot 4: ACF of Log(Close)
acf_logclose <- acf(data$log_Close, plot = FALSE, na.action = na.pass)
acf_df_logclose <- data.frame(Lag = acf_logclose$lag[,1,1], ACF = acf_logclose$acf[,1,1])
# Exclude lag 0 (always 1.0) to better see other lags
acf_df_logclose <- acf_df_logclose %>% filter(Lag > 0)
p4 <- ggplot(acf_df_logclose, aes(x = Lag, y = ACF)) +
geom_bar(stat = "identity", fill = "steelblue", width = 0.5) +
geom_hline(yintercept = 0, color = "black") +
geom_hline(yintercept = c(-1.96/sqrt(length(data$log_Close)), 1.96/sqrt(length(data$log_Close))),
linetype = "dashed", color = "red", alpha = 0.7) +
labs(title = "ACF of Log(Close Price)",
x = "Lag",
y = "ACF") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Combine plots
grid.arrange(p1, p2, p3, p4, ncol = 2)
# Plot log returns r(t)
ggplot(data, aes(x = Date, y = returns)) +
geom_line(color = "steelblue", linewidth = 0.6) +
geom_hline(yintercept = 0, color = "red", linetype = "dashed", alpha = 0.7) +
labs(title = "Log Returns r(t) = log(C_t) - log(C_{t-1})",
x = "Date",
y = "Log Returns") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# ADF Test (Augmented Dickey-Fuller)
# Test null hypothesis: series has unit root (non-stationary)
x <- na.omit(data$returns)
adf.test(x)
# KPSS Test (Kwiatkowski-Phillips-Schmidt-Shin)
# Test null hypothesis: series is stationary
kpss.test(data$returns, null = "Trend")
prepare_regression_data <- function(data) {
# Create log returns (dependent variable)
data$log_returns <- c(NA, diff(log(data$Close)))
# Create regressors
# r_{t-1} (lagged return)
data$lag_return <- lag(data$log_returns, 1)
# log(H_t / L_t) (intraday range = volatility proxy)
data$intraday_range <- log(data$High / data$Low)
# Δlog(Volume_t) (volume change)
data$log_Volume <- log(data$Volume)
data$delta_log_Volume <- c(NA, diff(data$log_Volume))
# Remove rows with NA values
data <- data %>% filter(!is.na(log_returns),
!is.na(lag_return),
!is.na(delta_log_Volume),
!is.na(intraday_range))
return(data)
}
# Prepare regression data
data_reg <- prepare_regression_data(data)
fit_model1 <- function(data) {
# Model: r_t = β₀ + β₁*r_{t-1} + β₂*Δlog(Vol_t) + β₃*log(H_t/L_t) + ε_t
model1 <- lm(log_returns ~ lag_return + delta_log_Volume + intraday_range,
data = data)
return(model1)
}
model1 <- fit_model1(data_reg)
summary(model1)
# Extract residuals from Model 1
res1 <- residuals(model1)
# ACF of residuals (show up to 40 lags, exclude lag 0)
acf_res_m1 <- acf(res1, lag.max = 40, plot = FALSE, na.action = na.pass)
acf_df_m1 <- data.frame(Lag = acf_res_m1$lag[,1,1], ACF = acf_res_m1$acf[,1,1]) %>%
filter(Lag > 0)
ggplot(acf_df_m1, aes(x = Lag, y = ACF)) +
geom_bar(stat = "identity", fill = "steelblue", width = 0.5) +
geom_hline(yintercept = 0, color = "black") +
geom_hline(yintercept = c(-1.96, 1.96) / sqrt(length(res1)),
linetype = "dashed", color = "red", alpha = 0.7) +
labs(title = "ACF of Residuals - Model 1 (OLS)",
x = "Lag",
y = "ACF") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# PACF of residuals
pacf_res_m1 <- pacf(res1, plot = FALSE, na.action = na.pass)
pacf_df_res_m1 <- data.frame(Lag = as.numeric(pacf_res_m1$lag), PACF = as.numeric(pacf_res_m1$acf))
p_pacf_m1 <- ggplot(pacf_df_res_m1, aes(x = Lag, y = PACF)) +
geom_bar(stat = "identity", fill = "darkgreen", width = 0.5) +
geom_hline(yintercept = 0, color = "black") +
geom_hline(yintercept = c(-1.96/sqrt(length(res1)), 1.96/sqrt(length(res1))),
linetype = "dashed", color = "red", alpha = 0.7) +
labs(title = "PACF of Residuals - Model 1 (OLS)",
x = "Lag",
y = "PACF") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Ljung-Box test
Box.test(res1, lag = 10, type = "Ljung-Box")
y  <- data_reg$log_returns
xreg <- cbind(data_reg$lag_return, data_reg$delta_log_Volume, data_reg$intraday_range)
# Non-seasonal
fit_ns <- auto.arima(y, xreg = xreg, seasonal = FALSE)
# Seasonal weekly
y7 <- ts(y, frequency = 7)
fit_s <- auto.arima(y7, xreg = xreg, seasonal = TRUE)
AIC(fit_ns, fit_s)
BIC(fit_ns, fit_s)
checkresiduals(fit_ns)
checkresiduals(fit_s)
res2 <- residuals(fit_s)
res2 <- res2[!is.na(res2)]
# Plot ACF of squared residuals
acf(res2^2, main = "ACF of Squared Residuals (Volatility Clustering Check)")
Box.test(res2^2, type = "Ljung-Box")
# ARCH LM Test
# Null hypothesis: No ARCH effects (homoskedasticity)
arch7  <- ArchTest(res2, lags = 7)
arch14 <- ArchTest(res2, lags = 14)
arch21 <- ArchTest(res2, lags = 21)
arch7; arch14; arch21
# Number of periods to forecast
h <- 5
# Prepare regression data using all data
xreg_all <- cbind(data_reg$lag_return, data_reg$delta_log_Volume, data_reg$intraday_range)
# Fit mean model on all data
fit_mean <- Arima(
ts(data_reg$log_returns, frequency = 7),
order = c(1,0,2),
seasonal = list(order = c(1,0,0), period = 7),
xreg = xreg_all,
method = "ML"
)
# For forecasting, we need future values of external regressors
# Use last known values as simple forecast for regressors
last_lag_return <- tail(data_reg$lag_return, 1)
last_delta_log_Volume <- tail(data_reg$delta_log_Volume, 1)
last_intraday_range <- tail(data_reg$intraday_range, 1)
# Create future xreg matrix (using last known values)
xreg_future <- matrix(
rep(c(last_lag_return, last_delta_log_Volume, last_intraday_range), h),
nrow = h, ncol = 3, byrow = TRUE
)
# Forecast mean returns
fc_mean <- forecast(fit_mean, h = h, xreg = xreg_future)
mu_hat <- as.numeric(fc_mean$mean)
# Get residuals for volatility modeling
res_all <- as.numeric(residuals(fit_mean))
res_all <- res_all[is.finite(res_all)]
# Fit GARCH model on residuals
spec <- ugarchspec(
variance.model = list(model="eGARCH", garchOrder=c(1,1)),
mean.model     = list(armaOrder=c(0,0), include.mean=FALSE),
distribution.model = "sstd"
)
fit_vol <- ugarchfit(spec, data = res_all, solver = "hybrid")
# Forecast volatility
fc_vol <- ugarchforecast(fit_vol, n.ahead = h)
sigma_eps_hat <- as.numeric(sigma(fc_vol))
# Create forecast results table
last_date <- max(data_reg$Date)
forecast_dates <- last_date + 1:h
forecast_results <- data.frame(
Date = forecast_dates,
Forecasted_Return = mu_hat,
Forecasted_Volatility = sigma_eps_hat,
Lower_95 = mu_hat - 1.96 * sigma_eps_hat,
Upper_95 = mu_hat + 1.96 * sigma_eps_hat
)
cat("=== 5-Day Return Forecasts ===\n")
print(forecast_results)
# Plot forecasted returns with confidence intervals
ggplot(forecast_results, aes(x = Date)) +
geom_line(aes(y = Forecasted_Return), color = "steelblue", linewidth = 1) +
geom_point(aes(y = Forecasted_Return), color = "steelblue", size = 3) +
geom_ribbon(aes(ymin = Lower_95, ymax = Upper_95), alpha = 0.2, fill = "steelblue") +
geom_hline(yintercept = 0, linetype = "dashed", color = "red", alpha = 0.7) +
labs(title = "5-Day Log Return Forecast with 95% Confidence Interval",
x = "Date",
y = "Forecasted Log Return") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Plot forecasted volatility
ggplot(forecast_results, aes(x = Date, y = Forecasted_Volatility)) +
geom_line(color = "darkgreen", linewidth = 1) +
geom_point(color = "darkgreen", size = 3) +
labs(title = "5-Day Volatility Forecast",
x = "Date",
y = "Forecasted Volatility (σ)") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
