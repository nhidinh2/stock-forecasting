## Stationarity Diagnostics
**Analysis Results:**
- **Close Price**: trend + ACF near 1 → non-stationary
## Testing Stationarity of r(t) (Log Returns)
Now let's plot r(t) and perform formal statistical tests to confirm stationarity.
### Plot of r(t)
### Statistical Tests for Stationarity
We perform two complementary tests:
1. **ADF (Augmented Dickey-Fuller) Test**:
2. **KPSS (Kwiatkowski-Phillips-Schmidt-Shin) Test**:
# Part A: Regression Analysis
## A1: Make Dependent Variable Stationary
We use log returns as our dependent variable: $r_t = \log(C_t) - \log(C_{t-1})$
### Model 1: OLS Regression
Model specification: $r_t = \beta_0 + \beta_1 r_{t-1} + \beta_2 \Delta\log(Vol_t) + \beta_3 \log(H_t/L_t) + \varepsilon_t$
### Check Residual ACF + Ljung-Box for Model 1
#### PACF of Residuals
#### Ljung-Box Test Results
### Interpretation
**Key Questions:**
**Expected for True Daily Close-to-Close:**
**Red Flags:**
**Note on Monday Gap Finding:**
This finding, combined with the lags at 6, 10, 17, 33, suggests the lag patterns might be related to:
**Recommendations to Address Lag Patterns:**
1. **Fix the `overnight_gap` feature**: Only compute gaps for consecutive calendar days (gap = 1), or adjust for weekend spans:
# Option B: Adjust for weekend spans
data$overnight_gap <- log(data$Open / data$lag_Close) / data$date_gap
```
2. **Add weekday dummies** to the model to capture day-of-week effects explicitly:
3. **Filter to weekdays only** if you want to remove weekend effects:
4. **Use trading-day indexing** instead of calendar-day indexing for lag analysis to avoid calendar artifacts.
## Plot: Close Price and Volume
# Step 1: Confirm Non-Stationarity
## Prepare Series
We examine multiple series: Close, log(Close), Volume, log(Volume), and returns.
## Stationarity Diagnostics
**Analysis Results:**
- **Close Price**: trend + ACF near 1 → non-stationary
## Testing Stationarity of r(t) (Log Returns)
# Introduction
This document performs a comprehensive time series analysis of stock data, following these steps:
- **Step 0**: Load and clean data, check trading days
# Step 0: Load + Clean
## Load and Clean Data
## Check Trading Days
## Execute Step 0
## Diagnose: Is Data Truly Daily Close-to-Close?
This section checks whether the data represents true daily close-to-close prices or if there are calendar artifacts.
### Visual Diagnostics
knitr::opts_chunk$set(
echo = TRUE,
warning = FALSE,
message = FALSE,
fig.width = 10,
fig.height = 6,
fig.align = "center"
)
knitr::opts_chunk$set(
echo = TRUE,
warning = FALSE,
message = FALSE,
fig.width = 10,
fig.height = 6,
fig.align = "center"
)
# Introduction
This document performs a comprehensive time series analysis of stock data, following these steps:
- **Step 0**: Load and clean data, check trading days
```{r libraries}
# Load required libraries
library(dplyr)
library(ggplot2)
library(gridExtra)
library(forecast)
library(lmtest)
library(tseries)
library(zoo)
library(lubridate)
library(lubridate)
library(knitr)
# Load required libraries
library(dplyr)
library(ggplot2)
library(gridExtra)
library(forecast)
library(lmtest)
library(tseries)
library(zoo)
library(lubridate)
library(knitr)
# Step 0: Load + Clean
## Load and Clean Data
```{r load-clean-functions}
# Load and clean data function
load_and_clean_data <- function(file_path) {
# Read CSV file (skip second row if it contains currency info)
data <- read.csv(file_path, stringsAsFactors = FALSE)
# Remove second row if it looks like a header row
if (nrow(data) > 1 && grepl("BTC-USD|USD", data[1, 2], ignore.case = TRUE)) {
data <- data[-1, ]
}
# Parse Date as datetime
data$Date <- as.Date(data$Date, format = "%Y-%m-%d")
# Convert numeric columns
data$Close <- as.numeric(data$Close)
data$Open <- as.numeric(data$Open)
data$High <- as.numeric(data$High)
data$Low <- as.numeric(data$Low)
data$Volume <- as.numeric(data$Volume)
# Sort ascending by date
data <- data %>% arrange(Date)
# Drop duplicates (keep first occurrence)
data <- data %>% distinct(Date, .keep_all = TRUE)
# Remove rows with missing values
data <- data %>% filter(!is.na(Date), !is.na(Close), !is.na(Volume))
return(data)
}
## Check Trading Days
## Execute Step 0
## Diagnose: Is Data Truly Daily Close-to-Close?
This section checks whether the data represents true daily close-to-close prices or if there are calendar artifacts.
## Check Trading Days
---
title: "Time Series Analysis: Stock Data"
# Introduction
knitr::opts_chunk$set(
echo = TRUE,
warning = FALSE,
message = FALSE,
fig.width = 10,
fig.height = 6,
fig.align = "center"
)
knitr::opts_chunk$set(
echo = TRUE,
warning = FALSE,
message = FALSE,
fig.width = 10,
fig.height = 6,
fig.align = "center"
)
# Introduction
This document performs a comprehensive time series analysis of stock data, following these steps:
- **Step 0**: Load and clean data, check trading days
```{r libraries}
# Load required libraries
library(dplyr)
library(ggplot2)
library(ggplot2)
library(gridExtra)
library(forecast)
library(forecast)
library(lmtest)
library(tseries)
library(zoo)
library(lubridate)
library(lubridate)
library(knitr)
# Load required libraries
library(dplyr)
library(ggplot2)
library(gridExtra)
library(forecast)
library(lmtest)
library(tseries)
library(zoo)
library(lubridate)
library(knitr)
# Step 0: Load + Clean
## Load and Clean Data
```{r load-clean-functions}
# Load and clean data function
load_and_clean_data <- function(file_path) {
# Read CSV file (skip second row if it contains currency info)
data <- read.csv(file_path, stringsAsFactors = FALSE)
# Remove second row if it looks like a header row
if (nrow(data) > 1 && grepl("BTC-USD|USD", data[1, 2], ignore.case = TRUE)) {
data <- data[-1, ]
}
# Parse Date as datetime
data$Date <- as.Date(data$Date, format = "%Y-%m-%d")
# Convert numeric columns
data$Close <- as.numeric(data$Close)
data$Open <- as.numeric(data$Open)
data$High <- as.numeric(data$High)
data$Low <- as.numeric(data$Low)
data$Volume <- as.numeric(data$Volume)
# Sort ascending by date
data <- data %>% arrange(Date)
# Drop duplicates (keep first occurrence)
data <- data %>% distinct(Date, .keep_all = TRUE)
# Remove rows with missing values
data <- data %>% filter(!is.na(Date), !is.na(Close), !is.na(Volume))
return(data)
}
## Check Trading Days
```{r trading-days-functions}
check_trading_days <- function(data) {
# Extract weekday (1 = Monday, 7 = Sunday)
data$Weekday <- wday(data$Date, week_start = 1)
# Check if weekends exist
has_weekends <- any(data$Weekday %in% c(6, 7))  # Saturday = 6, Sunday = 7
# Count days
total_days <- nrow(data)
weekend_count <- sum(data$Weekday %in% c(6, 7))
result <- list(
has_weekends = has_weekends,
total_days = total_days,
weekend_count = weekend_count
)
return(result)
}
return(result)
## Execute Step 0
```{r step0-execute}
# Set the CSV file path (modify as needed)
csv_file <- "archive/bitcoin.csv"
# Load and clean data
data <- load_and_clean_data(csv_file)
# Check trading days
check_trading_days(data)
# Check trading days
check_trading_days(data)
## Diagnose: Is Data Truly Daily Close-to-Close?
This section checks whether the data represents true daily close-to-close prices or if there are calendar artifacts.
```{r diagnose-daily-data}
# Function to diagnose daily data structure
diagnose_daily_data <- function(data) {
# Add weekday information
data$Weekday <- wday(data$Date, week_start = 1)
data$WeekdayName <- weekdays(data$Date)
# Calculate date gaps
data$date_gap <- c(NA, as.numeric(diff(data$Date)))
# Calculate returns (for analysis)
data$log_returns <- c(NA, diff(log(data$Close)))
# Calculate overnight gap (Open_t / Close_{t-1})
data$lag_Close <- lag(data$Close, 1)
data$overnight_gap <- log(data$Open / data$lag_Close)
# Check 1: Date gaps
cat("=== Date Gap Analysis ===\n")
gap_summary <- table(data$date_gap, useNA = "ifany")
cat("Distribution of date gaps:\n")
print(gap_summary)
cat("\n")
# Check 2: Weekend patterns
cat("=== Weekend Analysis ===\n")
weekend_data <- data %>% filter(Weekday %in% c(6, 7))
weekday_data <- data %>% filter(Weekday %in% 1:5)
cat(sprintf("Weekend days: %d (%.1f%%)\n", nrow(weekend_data),
100 * nrow(weekend_data) / nrow(data)))
cat(sprintf("Weekday days: %d (%.1f%%)\n", nrow(weekday_data),
100 * nrow(weekday_data) / nrow(data)))
cat("\n")
# Check 3: Overnight gap patterns by weekday
cat("=== Overnight Gap by Weekday ===\n")
gap_data <- data %>% filter(!is.na(overnight_gap), !is.na(Weekday))
if (nrow(gap_data) > 0) {
gap_by_weekday <- gap_data %>%
group_by(Weekday, WeekdayName) %>%
summarise(
count = n(),
mean_gap = mean(overnight_gap, na.rm = TRUE),
sd_gap = sd(overnight_gap, na.rm = TRUE),
abs_mean_gap = mean(abs(overnight_gap), na.rm = TRUE),
.groups = "drop"
) %>%
arrange(Weekday)
print(gap_by_weekday)
} else {
cat("No valid overnight gap data available.\n")
}
cat("\n")
# Check 4: Returns by weekday
cat("=== Returns by Weekday ===\n")
returns_data <- data %>% filter(!is.na(log_returns), !is.na(Weekday))
if (nrow(returns_data) > 0) {
returns_by_weekday <- returns_data %>%
group_by(Weekday, WeekdayName) %>%
summarise(
count = n(),
mean_return = mean(log_returns, na.rm = TRUE),
sd_return = sd(log_returns, na.rm = TRUE),
abs_mean_return = mean(abs(log_returns), na.rm = TRUE),
.groups = "drop"
) %>%
arrange(Weekday)
print(returns_by_weekday)
} else {
cat("No valid returns data available.\n")
}
cat("\n")
# Check 5: Volume by weekday
cat("=== Volume by Weekday ===\n")
volume_by_weekday <- data %>%
filter(!is.na(Weekday)) %>%
group_by(Weekday, WeekdayName) %>%
summarise(
count = n(),
mean_volume = mean(Volume, na.rm = TRUE),
median_volume = median(Volume, na.rm = TRUE),
.groups = "drop"
) %>%
arrange(Weekday)
print(volume_by_weekday)
cat("\n")
# Check 6: Check for Monday gaps (should be larger if weekends are included)
monday_gaps <- data %>%
filter(Weekday == 1, !is.na(overnight_gap)) %>%
pull(overnight_gap)
other_gaps <- data %>%
filter(Weekday != 1, !is.na(overnight_gap)) %>%
pull(overnight_gap)
cat("=== Monday vs Other Days Overnight Gap ===\n")
cat(sprintf("Monday mean |gap|: %.6f\n", mean(abs(monday_gaps), na.rm = TRUE)))
cat(sprintf("Other days mean |gap|: %.6f\n", mean(abs(other_gaps), na.rm = TRUE)))
cat(sprintf("Ratio (Monday/Other): %.2f\n",
mean(abs(monday_gaps), na.rm = TRUE) / mean(abs(other_gaps), na.rm = TRUE)))
# Statistical test
if (length(monday_gaps) > 0 && length(other_gaps) > 0) {
test_result <- t.test(abs(monday_gaps), abs(other_gaps))
cat(sprintf("t-test p-value: %.4f\n", test_result$p.value))
if (test_result$p.value < 0.05) {
cat("→ Monday gaps are significantly different (likely includes weekend effect)\n")
} else {
cat("→ Monday gaps are NOT significantly different\n")
}
}
cat("\n")
return(data)
}
### Visual Diagnostics
```{r visualize-daily-patterns}
# Plot 1: Overnight gaps by weekday
p1 <- ggplot(data %>% filter(!is.na(overnight_gap)),
aes(x = factor(Weekday, labels = c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")),
y = abs(overnight_gap))) +
geom_boxplot(fill = "steelblue", alpha = 0.7) +
labs(title = "Absolute Overnight Gap by Weekday",
x = "Weekday", y = "|log(Open_t / Close_{t-1})|") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Plot 2: Returns by weekday
p2 <- ggplot(data %>% filter(!is.na(log_returns)),
aes(x = factor(Weekday, labels = c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")),
y = abs(log_returns))) +
geom_boxplot(fill = "darkgreen", alpha = 0.7) +
labs(title = "Absolute Returns by Weekday",
x = "Weekday", y = "|log returns|") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Plot 4: Date gaps distribution
p4 <- ggplot(data %>% filter(!is.na(date_gap)),
aes(x = factor(date_gap))) +
geom_bar(fill = "purple", alpha = 0.7) +
labs(title = "Distribution of Date Gaps",
x = "Days Between Consecutive Observations", y = "Count") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
grid.arrange(p1, p2, p3, p4, ncol = 2)
### Interpretation
**Key Questions:**
**Expected for True Daily Close-to-Close:**
**Red Flags:**
**Note on Monday Gap Finding:**
This finding, combined with the lags at 6, 10, 17, 33, suggests the lag patterns might be related to:
**Recommendations to Address Lag Patterns:**
1. **Fix the `overnight_gap` feature**: Only compute gaps for consecutive calendar days (gap = 1), or adjust for weekend spans:
# Option B: Adjust for weekend spans
data$overnight_gap <- log(data$Open / data$lag_Close) / data$date_gap
2. **Add weekday dummies** to the model to capture day-of-week effects explicitly:
3. **Filter to weekdays only** if you want to remove weekend effects:
4. **Use trading-day indexing** instead of calendar-day indexing for lag analysis to avoid calendar artifacts.
## Plot: Close Price and Volume
```{r step0-plot}
# Plot Close and Volume over time
p1 <- ggplot(data, aes(x = Date, y = Close)) +
geom_line(color = "steelblue", linewidth = 0.8) +
labs(title = "Close Price Over Time",
x = "Date", y = "Close Price") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Plot Close and Volume over time
p1 <- ggplot(data, aes(x = Date, y = Close)) +
geom_line(color = "steelblue", linewidth = 0.8) +
labs(title = "Close Price Over Time",
x = "Date", y = "Close Price") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
p2 <- ggplot(data, aes(x = Date, y = Volume)) +
geom_line(color = "darkgreen", linewidth = 0.8) +
labs(title = "Volume Over Time",
x = "Date", y = "Volume") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
p2 <- ggplot(data, aes(x = Date, y = Volume)) +
geom_line(color = "darkgreen", linewidth = 0.8) +
labs(title = "Volume Over Time",
x = "Date", y = "Volume") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Combine plots
grid.arrange(p1, p2, ncol = 1)
# Step 1: Confirm Non-Stationarity
## Prepare Series
We examine multiple series: Close, log(Close), Volume, log(Volume), and returns.
```{r prepare-series}
data$log_Volume <- log(data$Volume)
# Calculate returns
data$returns <- c(NA, diff(data$log_Close))
# Calculate volatility proxy (intraday range)
data$volatility_proxy <- log(data$High / data$Low)
# Remove first row (has NA for returns)
data <- data[-1, ]
# Remove first row (has NA for returns)
data <- data[-1, ]
## Stationarity Diagnostics
```{r stationarity-plot}
# Define window for rolling statistics
window <- min(60, floor(nrow(data) / 10))
# Calculate rolling statistics
data$Close_rolling_mean <- rollmean(data$Close, k = window, fill = NA, align = "right")
data$Close_rolling_sd <- rollapply(data$Close, width = window, FUN = sd, fill = NA, align = "right")
data$log_Close_rolling_mean <- rollmean(data$log_Close, k = window, fill = NA, align = "right")
data$log_Close_rolling_sd <- rollapply(data$log_Close, width = window, FUN = sd, fill = NA, align = "right")
data$log_Volume_rolling_sd <- rollapply(data$log_Volume, width = window, FUN = sd, fill = NA, align = "right")
data$log_Volume_rolling_sd <- rollapply(data$log_Volume, width = window, FUN = sd, fill = NA, align = "right")
# Plot 1: Close Price with rolling statistics
p1 <- ggplot(data, aes(x = Date)) +
geom_line(aes(y = Close), color = "steelblue", linewidth = 0.6) +
geom_line(aes(y = Close_rolling_mean), color = "red", linewidth = 1, linetype = "dashed", na.rm = TRUE) +
geom_ribbon(aes(ymin = Close_rolling_mean - Close_rolling_sd,
ymax = Close_rolling_mean + Close_rolling_sd),
alpha = 0.2, fill = "red", na.rm = TRUE) +
labs(title = "Close Price with Rolling Mean ± SD (60-day window)",
x = "Date", y = "Close Price") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Plot 1: Close Price with rolling statistics
p1 <- ggplot(data, aes(x = Date)) +
geom_line(aes(y = Close), color = "steelblue", linewidth = 0.6) +
geom_line(aes(y = Close_rolling_mean), color = "red", linewidth = 1, linetype = "dashed", na.rm = TRUE) +
geom_ribbon(aes(ymin = Close_rolling_mean - Close_rolling_sd,
ymax = Close_rolling_mean + Close_rolling_sd),
alpha = 0.2, fill = "red", na.rm = TRUE) +
labs(title = "Close Price with Rolling Mean ± SD (60-day window)",
x = "Date", y = "Close Price") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Plot 2: Log(Close) with rolling statistics
p2 <- ggplot(data, aes(x = Date)) +
geom_line(aes(y = log_Close), color = "steelblue", linewidth = 0.6) +
geom_line(aes(y = log_Close_rolling_mean), color = "red", linewidth = 1, linetype = "dashed", na.rm = TRUE) +
geom_ribbon(aes(ymin = log_Close_rolling_mean - log_Close_rolling_sd,
ymax = log_Close_rolling_mean + log_Close_rolling_sd),
alpha = 0.2, fill = "red", na.rm = TRUE) +
labs(title = "Log(Close) with Rolling Mean ± SD (60-day window)",
x = "Date", y = "Log(Close Price)") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Plot 1: Close Price with rolling statistics
p1 <- ggplot(data, aes(x = Date)) +
geom_line(aes(y = Close), color = "steelblue", linewidth = 0.6) +
geom_line(aes(y = Close_rolling_mean), color = "red", linewidth = 1, linetype = "dashed", na.rm = TRUE) +
geom_ribbon(aes(ymin = Close_rolling_mean - Close_rolling_sd,
ymax = Close_rolling_mean + Close_rolling_sd),
alpha = 0.2, fill = "red", na.rm = TRUE) +
labs(title = "Close Price with Rolling Mean ± SD (60-day window)",
x = "Date", y = "Close Price") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Plot 2: Log(Close) with rolling statistics
p2 <- ggplot(data, aes(x = Date)) +
geom_line(aes(y = log_Close), color = "steelblue", linewidth = 0.6) +
geom_line(aes(y = log_Close_rolling_mean), color = "red", linewidth = 1, linetype = "dashed", na.rm = TRUE) +
geom_ribbon(aes(ymin = log_Close_rolling_mean - log_Close_rolling_sd,
ymax = log_Close_rolling_mean + log_Close_rolling_sd),
alpha = 0.2, fill = "red", na.rm = TRUE) +
labs(title = "Log(Close) with Rolling Mean ± SD (60-day window)",
x = "Date", y = "Log(Close Price)") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Plot 3: ACF of Close
acf_close <- acf(data$Close, plot = FALSE, na.action = na.pass)
# Plot 4: ACF of Log(Close)
acf_logclose <- acf(data$log_Close, plot = FALSE, na.action = na.pass)
acf_df_logclose <- data.frame(Lag = acf_logclose$lag[,1,1], ACF = acf_logclose$acf[,1,1])
p4 <- ggplot(acf_df_logclose, aes(x = Lag, y = ACF)) +
geom_bar(stat = "identity", fill = "steelblue", width = 0.5) +
geom_hline(yintercept = 0, color = "black") +
geom_hline(yintercept = c(-1.96/sqrt(length(data$log_Close)), 1.96/sqrt(length(data$log_Close))),
linetype = "dashed", color = "red", alpha = 0.7) +
labs(title = "ACF of Log(Close Price)",
x = "Lag", y = "ACF") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Combine plots
grid.arrange(p1, p2, p3, p4, ncol = 2)
# Plot 3: ACF of Close
acf_close <- acf(data$Close, plot = FALSE, na.action = na.pass)
acf_df_close <- data.frame(Lag = acf_close$lag[,1,1], ACF = acf_close$acf[,1,1])
p3 <- ggplot(acf_df_close, aes(x = Lag, y = ACF)) +
geom_bar(stat = "identity", fill = "steelblue", width = 0.5) +
geom_hline(yintercept = 0, color = "black") +
geom_hline(yintercept = c(-1.96/sqrt(length(data$Close)), 1.96/sqrt(length(data$Close))),
linetype = "dashed", color = "red", alpha = 0.7) +
labs(title = "ACF of Close Price",
x = "Lag", y = "ACF") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Plot 4: ACF of Log(Close)
acf_logclose <- acf(data$log_Close, plot = FALSE, na.action = na.pass)
